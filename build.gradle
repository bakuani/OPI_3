import javax.sound.sampled.*
import javax.xml.parsers.DocumentBuilderFactory
import org.gradle.api.plugins.jvm.JvmTestSuite
import java.util.concurrent.ThreadLocalRandom

plugins {
    id 'org.springframework.boot' version '3.4.5'
    id 'io.spring.dependency-management' version '1.1.0'
    id 'jvm-test-suite'
    id 'java'
}

version = project.findProperty('projectVersion') ?: '1.0'
def mainClass = project.findProperty('mainClassName') ?: 'com.example.Main'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

allprojects {
    group = 'ru.ani'
    description = 'Web4 Project (Backend)'
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter'

    compileOnly 'org.projectlombok:lombok:1.18.30'
    annotationProcessor 'org.projectlombok:lombok:1.18.30'

    runtimeOnly 'org.postgresql:postgresql:42.7.4'

    implementation 'org.springframework.boot:spring-boot-starter-security'

    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.5'

    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

jar {
    manifest {
        attributes(
                'Main-Class': mainClass,
                'Implementation-Version': project.version
        )
    }
}

testing {
    suites {
        test(JvmTestSuite) {
            useJUnitJupiter()
        }
    }
}

tasks.register('compile') {
    group = 'Custom'
    description = 'Compile sources'
    dependsOn 'classes'
}

tasks.register('buildJar') {
    group = 'Custom'
    description = 'Build JAR file'
    dependsOn 'compile', 'bootJar'
}

tasks.register('cleanArtifacts') {
    group = 'Custom'
    description = 'Clean build artifacts'
    dependsOn 'clean'
}

tasks.register('unitTest') {
    group = 'Custom'
    description = 'Run JUnit tests'
    dependsOn 'buildJar', 'test'

    doLast {
        println 'JUnit tests completed.'
    }
}

tasks.register('music') {
    group = 'Custom'
    description = 'Play music (la la la)'
    dependsOn 'buildJar'

    doLast {
        File musicDir = file("music")
        File[] audioFiles = musicDir.listFiles({ file -> file.name.toLowerCase().endsWith(".wav") } as FileFilter)

        if (audioFiles == null || audioFiles.length == 0) {
            println "No .wav files found in the music directory."
            return
        }

        println 'Playing random music...'

        File randomFile = audioFiles[ThreadLocalRandom.current().nextInt(audioFiles.length)]

        AudioInputStream ais = AudioSystem.getAudioInputStream(randomFile)
        Clip clip = AudioSystem.getClip()
        clip.open(ais)
        clip.start()

        Thread.sleep((long) (clip.getMicrosecondLength() / 1000))

        clip.close()
        ais.close()
    }
}

tasks.register('native2ascii') {
    group = 'Custom'
    description = 'Convert .properties files from UTF-8 to ASCII'

    def srcDir = file('src/main/resources/locales/')
    def destDir = layout.buildDirectory.dir('converted-resources').get().asFile

    inputs.dir srcDir
    outputs.dir destDir

    doLast {
        ant.native2ascii(
                src: srcDir,
                dest: destDir,
                encoding: 'UTF-8',
                includes: '**/*.properties'
        )
    }
}

// TODO
tasks.register('doc', Javadoc) {
    group = 'Custom'
    description = 'Generate JavaDoc'
    destinationDir = file("$buildDir/docs/javadoc")
    options.encoding = 'UTF-8'
}

// TODO
tasks.register('docArchive', Zip) {
    group = 'Custom'
    description = 'Archive JavaDoc with MD5 and SHA1 checksums'
    dependsOn 'doc'
    from doc.destinationDir
    archiveFileName = "docs-${project.version}.zip"
    doLast {
        println 'Calculating MD5 and SHA1 for documentation files...'
        fileTree(dir: doc.destinationDir, include: '**/*').files.each { File file ->
            // Generate MD5
            def md5 = file.bytes.encodeHex().toString()
            file("${file}.md5").text = md5
            def sha1Digest = java.security.MessageDigest.getInstance("SHA-1")
            sha1Digest.update(file.bytes)
            def sha1 = sha1Digest.digest().encodeHex().toString()
            file("${file}.sha1").text = sha1
        }
    }
}

tasks.register('xmlValidate') {
    group = 'Custom'
    description = 'Validate all project XML files'

    def mainDir = project.projectDir

    doLast {
        println 'Validating XML files...'

        def factory = DocumentBuilderFactory.newInstance()
        factory.setNamespaceAware(true)
        factory.setValidating(false)

        def builder = factory.newDocumentBuilder()
        fileTree(dir: mainDir, include: '**/*.xml').each { File xmlFile ->
            try {
                xmlFile.withInputStream { is -> builder.parse(is) }
                println "Valid: ${xmlFile}"
            } catch (Exception ignored) {
                println "XML validation error in file: ${xmlFile}"
            }
        }
    }
}

// TODO
tasks.register('scp') {
    group = 'Custom'
    description = 'Transfer the built JAR to a remote server via SCP'
    dependsOn 'buildJar'
    doLast {
        println 'Executing SCP transfer...'
    }
    // Replace user@server:/path with actual values
    // commandLine 'scp', "${buildDir}/libs/${project.name}-${project.version}.jar", 'user@server:/remote/path/'
}

// TODO
tasks.register('team') {
    group = 'Custom'
    description = 'Retrieve last 4 SVN revisions and package them into ZIP'
    doLast {
        println 'Fetching last 4 SVN revisions...'
        def revisions = []
        def log = 'svn log -l 4 --quiet'.execute().text
        log.eachLine { line ->
            if (line =~ /^r(\d+)/) {
                revisions << (line =~ /^r(\d+)/)[0][1]
            }
        }
        def tmpDir = file("$buildDir/svnRevs")
        tmpDir.mkdirs()
        revisions.each { rev ->
            println "Updating SVN to revision $rev and building project..."
            exec { commandLine 'svn', 'update', '-r', rev }
            exec { commandLine 'gradle', 'buildJar' }  // recursive task invocation
            copy {
                from "${buildDir}/libs/${project.name}-${project.version}.jar"
                into tmpDir
                rename { "${project.name}-${rev}.jar" }
            }
        }
        ant.zip(destfile: "$buildDir/archives/team_revisions.zip", basedir: tmpDir)
        println 'Archive with previous revisions is ready.'
    }
}

tasks.register('env', JavaExec) {
    group = 'Build'
    description = 'Build and run the JAR with custom environment settings from env.properties'
    dependsOn 'buildJar'

    def envFile = file("env.properties")
    if (!envFile.exists()) {
        throw new GradleException("File env.properties not found in project root")
    }

    def props = new Properties()
    envFile.withInputStream { props.load(it) }

    def mainClassName = props.getProperty("main.class", "ru.ani.web.BackendApplication")
    def javaVersionStr = props.getProperty("java.version", "23")
    def jvmArgsProp = props.getProperty("jvm.args", "")
    def customJvmArgs = jvmArgsProp.tokenize()

    println "Running with main class: ${mainClassName}"
    println "Java version: ${javaVersionStr}"
    println "JVM arguments: ${customJvmArgs}"

    def jarTask = tasks.named('bootJar').get() as Jar
    def jarFile = jarTask.archiveFile.get().asFile

    executable = javaLauncher.get().executablePath
    args = ['-jar', jarFile.absolutePath]
    jvmArgs = customJvmArgs

    javaLauncher.set(javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(javaVersionStr.toInteger())
    })
}

tasks.register('report') {
    group = 'Custom'
    description = 'Save JUnit reports (XML) and commit them to Git after successful tests'
    dependsOn 'unitTest'

    doLast {
        def resultsDir = file("build/test-results/test")
        if (!resultsDir.exists() || resultsDir.listFiles()?.length == 0) {
            println "No JUnit reports found in build/test-results/test. Tests might not have run."
            return
        }

        def xmls = resultsDir.listFiles().findAll { it.name.endsWith('.xml') }
        if (!xmls) {
            println "No XML reports found for commit"
            return
        }

        println "Adding the following JUnit reports to Git:"
        xmls.each { f ->
            println "  - ${f.name}"
            exec {
                commandLine 'git', 'add', f.absolutePath
            }
        }

        println "Executing git commit..."
        exec {
            commandLine 'git', 'commit', '-m', "Add JUnit reports: ${xmls*.name.join(', ')}"
        }
        println "JUnit reports committed successfully."
    }
}

// TODO
tasks.register('alt') {
    group = 'Custom'
    description = 'Create alternative version with name replacement via regex'
    doLast {
        println 'Generating alternative project version with name replacement...'
        def altSrcDir = file("$buildDir/altSrc")
        copy {
            from 'src/main/java'
            into altSrcDir
            filter { String line -> line.replaceAll('OldName', 'NewName') }
        }
        ant.javac(srcdir: altSrcDir, destdir: "$buildDir/altClasses",
                classpath: configurations.compileClasspath.asPath)
        ant.jar(destfile: "$buildDir/libs/${project.name}-alt.jar", basedir: "$buildDir/altClasses",
                manifest: ['Main-Class': mainClass])
        println 'Alternative JAR created: ' + "$buildDir/libs/${project.name}-alt.jar"
    }
}

// TODO
tasks.register('diff') {
    group = 'Custom'
    description = 'Check Git status and auto-commit changes if present'
    doLast {
        println 'Checking for Git changes...'
        def status = 'git status --porcelain'.execute().text.trim()
        if (status) {
            println 'Changes detected, committing...'
            exec { commandLine 'git', 'add', '--all' }
            exec { commandLine 'git', 'commit', '-m', "Auto commit changes" }
        } else {
            println 'No changes to commit.'
        }
    }
}

// TODO
tasks.register('history') {
    group = 'Custom'
    description = 'Automatically revert to previous SVN revisions if build fails'
    doLast {
        println 'Attempting to build the project...'
        def currentRev = ('svn info --show-item revision'.execute().text.trim() as int)
        def rev = currentRev
        while (rev > 0) {
            try {
                exec { commandLine 'gradle', 'buildJar' }
                println "Build successful at revision $rev."
                break
            } catch (Exception e) {
                rev--
                if (rev <= 0) {
                    println 'Failed to build any revision.'
                    break
                }
                println "Build failed, reverting to revision $rev..."
                exec { commandLine 'svn', 'update', '-r', rev.toString() }
            }
        }
    }
}