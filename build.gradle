import org.gradle.api.plugins.jvm.JvmTestSuite

import javax.sound.sampled.AudioInputStream
import javax.sound.sampled.AudioSystem
import javax.sound.sampled.Clip
import javax.xml.parsers.DocumentBuilderFactory
import java.security.MessageDigest
import java.util.concurrent.ThreadLocalRandom

plugins {
    id 'org.springframework.boot' version '3.4.5'
    id 'io.spring.dependency-management' version '1.1.0'
    id 'jvm-test-suite'
    id 'java'
}

version = project.findProperty('projectVersion') ?: '1.0'
def mainClass = project.findProperty('mainClassName') ?: 'com.example.Main'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

allprojects {
    group = 'ru.ani'
    description = 'Web4 Project (Backend)'
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter'

    compileOnly 'org.projectlombok:lombok:1.18.30'
    annotationProcessor 'org.projectlombok:lombok:1.18.30'

    runtimeOnly 'org.postgresql:postgresql:42.7.4'

    implementation 'org.springframework.boot:spring-boot-starter-security'

    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.5'

    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

jar {
    manifest {
        attributes(
                'Main-Class': mainClass,
                'Implementation-Version': project.version
        )
    }
}

testing {
    suites {
        test(JvmTestSuite) {
            useJUnitJupiter()
        }
    }
}

tasks.register('compile') {
    group = 'Custom'
    description = 'Compile sources'
    dependsOn 'classes'
}

tasks.register('buildJar') {
    group = 'Custom'
    description = 'Build JAR file'
    dependsOn 'compile', 'bootJar'
}

tasks.register('cleanArtifacts') {
    group = 'Custom'
    description = 'Clean build artifacts'
    dependsOn 'clean'
}

tasks.register('unitTest') {
    group = 'Custom'
    description = 'Run JUnit tests'
    dependsOn 'buildJar', 'test'

    doLast {
        println 'JUnit tests completed.'
    }
}

tasks.register('music') {
    group = 'Custom'
    description = 'Play music (la la la)'
    dependsOn 'buildJar'

    doLast {
        File musicDir = file("music")
        File[] audioFiles = musicDir.listFiles({ file -> file.name.toLowerCase().endsWith(".wav") } as FileFilter)

        if (audioFiles == null || audioFiles.length == 0) {
            println "No .wav files found in the music directory."
            return
        }

        println 'Playing random music...'

        File randomFile = audioFiles[ThreadLocalRandom.current().nextInt(audioFiles.length)]

        AudioInputStream ais = AudioSystem.getAudioInputStream(randomFile)
        Clip clip = AudioSystem.getClip()
        clip.open(ais)
        clip.start()

        Thread.sleep((long) (clip.getMicrosecondLength() / 1000))

        clip.close()
        ais.close()
    }
}

tasks.register('native2ascii') {
    group = 'Custom'
    description = 'Convert .properties files from UTF-8 to ASCII'

    def srcDir = file('src/main/resources/locales/')
    def destDir = layout.buildDirectory.dir('converted-resources').get().asFile

    inputs.dir srcDir
    outputs.dir destDir

    doLast {
        ant.native2ascii(
                src: srcDir,
                dest: destDir,
                encoding: 'UTF-8',
                includes: '**/*.properties'
        )
    }
}


tasks.register('doc', Javadoc) {
    group = 'Custom'
    description = 'Generate Javadoc, compute MD5/SHAâ€‘1 of bootJar, write MANIFEST.MF and pack docs into ZIP'
    dependsOn 'bootJar'

    source = sourceSets.main.allJava
    classpath = sourceSets.main.compileClasspath

    destinationDir = layout.buildDirectory.dir('docs/javadoc').get().asFile
    options.encoding = 'UTF-8'

    doLast {
        def docsDir = destinationDir
        def metaInf = new File(docsDir, 'META-INF')
        metaInf.mkdirs()

        def mainJar = tasks.named('bootJar', Jar).get().archiveFile.get().asFile
        def bytes = mainJar.bytes

        def md5 = MessageDigest.getInstance('MD5').digest(bytes).encodeHex().toString()
        def sha1 = MessageDigest.getInstance('SHA-1').digest(bytes).encodeHex().toString()

        def mf = new File(metaInf, 'MANIFEST.MF')
        mf.text = """Manifest-Version: 1.0
Project-MD5: ${md5}
Project-SHA1: ${sha1}
"""

        def zipFile = layout.buildDirectory.file("archives/${project.name}-${project.version}-javadoc.zip").get().asFile
        ant.zip(destfile: zipFile, basedir: docsDir)

        println "Javadoc ZIP with manifest written to: ${zipFile}"
    }
}


tasks.register('xmlValidate') {
    group = 'Custom'
    description = 'Validate all project XML files'

    def mainDir = project.projectDir

    doLast {
        println 'Validating XML files...'

        def factory = DocumentBuilderFactory.newInstance()
        factory.setNamespaceAware(true)
        factory.setValidating(false)

        def builder = factory.newDocumentBuilder()
        fileTree(dir: mainDir, include: '**/*.xml').each { File xmlFile ->
            try {
                xmlFile.withInputStream { is -> builder.parse(is) }
                println "Valid: ${xmlFile}"
            } catch (Exception ignored) {
                println "XML validation error in file: ${xmlFile}"
            }
        }
    }
}

tasks.register('scp', Exec) {
    group = 'Custom'
    description = 'Transfer the built JAR via SCP in WSL'
    dependsOn 'buildJar'

    doFirst {
        def envFile = file("scp.properties")
        if (!envFile.exists()) {
            throw new GradleException("File scp.properties not found in project root")
        }

        def props = new Properties()
        envFile.withInputStream { props.load(it) }

        def password = props.getProperty("password")
        def remoteUser = props.getProperty("remoteUser")
        def remoteHost = props.getProperty("remoteHost")
        def remotePort = props.getProperty("remotePort")
        def remotePath = props.getProperty("remotePath")

        def jarFile = tasks.named('bootJar').get().archiveFile.get().asFile
        def winPath = jarFile.absolutePath
        def driveLetter = winPath.substring(0, 1).toLowerCase()
        def wslPath = winPath.replaceAll('\\\\', '/')
                .replaceFirst(/^[a-zA-Z]:/, "/mnt/${driveLetter}")

        println "Executing SCP transfer using WSL for file ${wslPath}"

        commandLine 'wsl', 'sshpass', '-p', password,
                'scp', '-P', remotePort, wslPath,
                "${remoteUser}@${remoteHost}:${remotePath}"
    }
}

tasks.register('team') {
    group = 'Custom'
    description = 'Retrieve last 2 SVN revisions and package them into ZIP'
    dependsOn 'buildJar'

    doLast {
        println 'Fetching last 2 SVN revisions...'

        def revisions = []
        def log = 'svn log -l 2 --quiet'.execute().text
        log.eachLine { line ->
            def matcher = (line =~ /^r(\d+)/)
            if (matcher.find()) {
                revisions << matcher.group(1)
            }
        }

        def tmpDir = file("$buildDir/svnRevs")
        tmpDir.mkdirs()

        revisions.each { rev ->
            println "Updating to revision $rev..."
            exec {
                commandLine 'svn', 'update', '-r', rev,
                        '--username', 'urasha', '--password', 'admin', '--non-interactive'
            }

            println "Building jar for revision $rev..."

            copy {
                from file("${buildDir}/libs/${project.name}-${project.version}.jar")
                into tmpDir
                rename { "${project.name}-${rev}.jar" }
            }
        }

        ant.zip(destfile: "$buildDir/archives/team_revisions.zip", basedir: tmpDir)
        println 'Archive with previous revisions is ready.'
    }
}


tasks.register('env', JavaExec) {
    group = 'Build'
    description = 'Build and run the JAR with custom environment settings from env.properties'
    dependsOn 'buildJar'

    def envFile = file("env.properties")
    if (!envFile.exists()) {
        throw new GradleException("File env.properties not found in project root")
    }

    def props = new Properties()
    envFile.withInputStream { props.load(it) }

    def mainClassName = props.getProperty("main.class", "ru.ani.web.BackendApplication")
    def javaVersionStr = props.getProperty("java.version", "23")
    def jvmArgsProp = props.getProperty("jvm.args", "")
    def customJvmArgs = jvmArgsProp.tokenize()

    println "Running with main class: ${mainClassName}"
    println "Java version: ${javaVersionStr}"
    println "JVM arguments: ${customJvmArgs}"

    def jarTask = tasks.named('bootJar').get() as Jar
    def jarFile = jarTask.archiveFile.get().asFile

    executable = javaLauncher.get().executablePath
    args = ['-jar', jarFile.absolutePath]
    jvmArgs = customJvmArgs

    javaLauncher.set(javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(javaVersionStr.toInteger())
    })
}

tasks.register('report') {
    group = 'Custom'
    description = 'Save JUnit reports (XML) and commit them to Git after successful tests'
    dependsOn 'unitTest'

    doLast {
        def resultsDir = file("build/test-results/test")
        if (!resultsDir.exists() || resultsDir.listFiles()?.length == 0) {
            println "No JUnit reports found in build/test-results/test. Tests might not have run."
            return
        }

        def xmls = resultsDir.listFiles().findAll { it.name.endsWith('.xml') }
        if (!xmls) {
            println "No XML reports found for commit"
            return
        }

        println "Adding the following JUnit reports to Git:"
        xmls.each { f ->
            println "  - ${f.name}"
            exec {
                commandLine 'git', 'add', f.absolutePath
            }
        }

        println "Executing git commit..."
        exec {
            commandLine 'git', 'commit', '-m', "Add JUnit reports: ${xmls*.name.join(', ')}"
        }
        println "JUnit reports committed successfully."
    }
}

tasks.register('alt') {
    group = 'Custom'
    description = 'Create alternative version by replacing text in sources according to alt.properties and repackage JAR as alt.jar'

    doLast {
        def sourceDir = file("src/main/java")
        def altPropertiesFile = file("alt.properties")
        if (!altPropertiesFile.exists()) {
            throw new GradleException("File alt.properties not found. Please create it.")
        }

        def altMapping = new Properties()
        altPropertiesFile.withInputStream { stream ->
            altMapping.load(stream)
        }
        println "Loaded replacements: ${altMapping}"

        fileTree(sourceDir).matching { include '**/*.java' }.each { File file ->
            def text = file.text
            altMapping.each { key, value ->
                text = text.replaceAll(key.toString(), value.toString())
            }
            file.write(text)
        }
    }

    tasks.alt.finalizedBy(tasks.build.configure {
        tasks.bootJar.archiveFileName = 'alt.jar'
    })
}

tasks.register('gitAdd', Exec) {
    group = 'Custom'
    description = 'Add all changes in Git'
    commandLine 'git', 'add', '--all'
}

tasks.register('gitCommit', Exec) {
    group = 'Custom'
    description = 'Commit changes in Git'
    commandLine 'git', 'commit', '-m', 'Auto commit changes'
}

tasks.register('diff') {
    group = 'Custom'
    description = 'Check Git status and auto-commit changes if present'
    doLast {
        println 'Checking for Git changes...'
        def status = 'git status --porcelain'.execute().text.trim()
        if (status) {
            println 'Changes detected, committing...'
            tasks.named("gitAdd").get().exec()
            tasks.named("gitCommit").get().exec()
        } else {
            println 'No changes to commit.'
        }
    }
}

tasks.register('history') {
    group = 'Custom'
    description = 'Automatically revert to previous SVN revisions if build fails'

    doLast {
        println 'Attempting to build the project...'

        def currentRev = ('svn info -r HEAD --show-item revision'.execute().text.trim() as int)
        def rev = currentRev

        while (rev > 0) {
            try {
                exec {
                    commandLine "${projectDir}\\gradlew.bat", 'compile'
                }
                println "Build successful at revision $rev."
                break
            } catch (Exception e) {
                println e
                rev--
                if (rev <= 0) {
                    println 'Failed to build any revision.'
                    break
                }

                println "Build failed, reverting to revision $rev..."

                exec { commandLine 'svn', 'update', '-r', rev.toString() }

                if (rev + 1 <= currentRev) {
                    println "Generating diff between revision ${rev + 1} and $rev..."
                    def diffFile = file("$buildDir/svn_diff_rev_${rev}.patch")
                    exec {
                        commandLine 'svn', 'diff', '-r', "${rev + 1}:${rev}"
                        standardOutput = diffFile.newOutputStream()
                    }
                    println "Diff file created: ${diffFile.absolutePath}"
                }
            }
        }
    }
}